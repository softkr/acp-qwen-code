#!/usr/bin/env node

import { compile } from "json-schema-to-typescript";
import { generate } from "ts-to-zod";
import fs from "fs";

const jsonSchema = JSON.parse(fs.readFileSync("./schema/schema.json", "utf8"));
const metadata = JSON.parse(fs.readFileSync("./schema/meta.json", "utf8"));

const tsSrc = await compile(jsonSchema, "Agent Client Protocol", {
  additionalProperties: false,
  bannerComment: false,
});

const zodGenerator = generate({
  sourceText: tsSrc,
  bannerComment: false,
  keepComments: false,
});
const zodSchemas = zodGenerator.getZodSchemasFile();

const schemaTs = `
export const AGENT_METHODS = ${JSON.stringify(metadata.agentMethods, null, 2)};

export const CLIENT_METHODS = ${JSON.stringify(metadata.clientMethods, null, 2)};

export const PROTOCOL_VERSION = ${metadata.version};

import { z } from "zod";

${markSpecificTypesAsInternal(tsSrc)}

${markZodSchemasAsInternal(fixGeneratedZod(zodSchemas))}
`;

function fixGeneratedZod(src) {
  return src
    .replace(`// Generated by ts-to-zod\nimport { z } from "zod";\n`, "")
    .replace(`import * as generated from "./zod";\n`, "")
    .replace(/typeof generated./g, "typeof ");
}

function markSpecificTypesAsInternal(src) {
  const typesToExclude = [
    "AgentRequest",
    "AgentResponse",
    "AgentNotification",
    "ClientRequest",
    "ClientResponse",
    "ClientNotification",
  ];

  let result = src;

  for (const typeName of typesToExclude) {
    const regex = new RegExp(`(export type ${typeName}\\b)`, "g");
    result = result.replace(regex, "/** @internal */\n$1");
  }

  return result;
}

function markZodSchemasAsInternal(src) {
  // Mark all zod schemas as internal - they're implementation details
  return src.replace(/(export const \w+Schema = )/g, "/** @internal */\n$1");
}

fs.writeFileSync("typescript/schema.ts", schemaTs, "utf8");
